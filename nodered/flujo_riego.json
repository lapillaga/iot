[
    {
        "id": "flow_riego",
        "type": "tab",
        "label": "Sistema Riego IoT",
        "disabled": false,
        "info": "Sistema de riego inteligente con ML y datos clim√°ticos"
    },
    {
        "id": "mqtt_broker_hivemq",
        "type": "mqtt-broker",
        "name": "HiveMQ Cloud",
        "broker": "3f53469d473648f8a48abff7da04d106.s1.eu.hivemq.cloud",
        "port": "8883",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "sessionExpiry": ""
    },
    {
        "id": "influxdb_config",
        "type": "influxdb",
        "hostname": "us-east-1-1.aws.cloud2.influxdata.com",
        "port": "443",
        "protocol": "https",
        "database": "riego_iot",
        "name": "InfluxDB Cloud",
        "usetls": true,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "https://us-east-1-1.aws.cloud2.influxdata.com",
        "rejectUnauthorized": true
    },
    {
        "id": "comment_sensores",
        "type": "comment",
        "z": "flow_riego",
        "name": "üìä RECEPCI√ìN DE DATOS DE SENSORES",
        "info": "",
        "x": 200,
        "y": 40,
        "wires": []
    },
    {
        "id": "mqtt_in_sensores",
        "type": "mqtt in",
        "z": "flow_riego",
        "name": "üì° Sensores ESP32",
        "topic": "pastizal/sensores",
        "qos": "0",
        "datatype": "json",
        "broker": "mqtt_broker_hivemq",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 100,
        "wires": [["function_procesar", "function_influx"]]
    },
    {
        "id": "function_procesar",
        "type": "function",
        "z": "flow_riego",
        "name": "‚öôÔ∏è Procesar datos",
        "func": "var datos = msg.payload;\nflow.set('ultimosDatos', datos);\n\nmsg.sensorData = {\n    humedad_suelo: datos.humedad_suelo,\n    temperatura: datos.temperatura,\n    humedad_ambiente: datos.humedad_ambiente,\n    valvula: datos.valvula,\n    timestamp: new Date().toISOString()\n};\n\nnode.status({fill:\"green\", shape:\"dot\", text: \"Hum: \" + datos.humedad_suelo + \"%\"});\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 80,
        "wires": [["debug_sensores"]]
    },
    {
        "id": "debug_sensores",
        "type": "debug",
        "z": "flow_riego",
        "name": "üîç Ver datos sensores",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload.humedad_suelo",
        "statusType": "msg",
        "x": 620,
        "y": 80,
        "wires": []
    },
    {
        "id": "comment_influx",
        "type": "comment",
        "z": "flow_riego",
        "name": "üíæ GUARDAR EN INFLUXDB",
        "info": "",
        "x": 180,
        "y": 140,
        "wires": []
    },
    {
        "id": "function_influx",
        "type": "function",
        "z": "flow_riego",
        "name": "üì¶ Preparar para InfluxDB",
        "func": "var datos = msg.payload;\n\nmsg.payload = {\n    humedad_suelo: parseFloat(datos.humedad_suelo),\n    temperatura: parseFloat(datos.temperatura),\n    humedad_ambiente: parseFloat(datos.humedad_ambiente),\n    valvula: datos.valvula === \"ON\" ? 1 : 0\n};\n\nmsg.measurement = \"sensores_pastizal\";\n\nnode.status({fill:\"blue\", shape:\"dot\", text:\"Hum: \" + datos.humedad_suelo + \"%\"});\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 140,
        "wires": [["influxdb_out"]]
    },
    {
        "id": "influxdb_out",
        "type": "influxdb out",
        "z": "flow_riego",
        "influxdb": "influxdb_config",
        "name": "üíæ InfluxDB Cloud",
        "measurement": "",
        "precision": "",
        "retentionPolicy": "",
        "database": "riego_iot",
        "retentionPolicyV18Flux": "",
        "org": "e94345dd9c8f95c7",
        "bucket": "riego_iot",
        "x": 650,
        "y": 140,
        "wires": []
    },
    {
        "id": "comment_clima",
        "type": "comment",
        "z": "flow_riego",
        "name": "üå§Ô∏è CONSULTA API CLIMA (Open-Meteo)",
        "info": "",
        "x": 210,
        "y": 220,
        "wires": []
    },
    {
        "id": "inject_clima",
        "type": "inject",
        "z": "flow_riego",
        "name": "‚è∞ Cada 30 min",
        "props": [],
        "repeat": "1800",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "x": 160,
        "y": 280,
        "wires": [["http_clima"]]
    },
    {
        "id": "http_clima",
        "type": "http request",
        "z": "flow_riego",
        "name": "üå§Ô∏è Open-Meteo API",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://api.open-meteo.com/v1/forecast?latitude=-2.690425&longitude=-78.935117&current=temperature_2m,relative_humidity_2m,precipitation&hourly=precipitation_probability&daily=precipitation_sum,precipitation_probability_max&timezone=America/Guayaquil&forecast_days=3",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 390,
        "y": 280,
        "wires": [["function_clima"]]
    },
    {
        "id": "function_clima",
        "type": "function",
        "z": "flow_riego",
        "name": "üìä Procesar clima",
        "func": "var clima = msg.payload;\n\nvar datosClima = {\n    temp_actual: clima.current.temperature_2m,\n    humedad_actual: clima.current.relative_humidity_2m,\n    precipitacion_actual: clima.current.precipitation,\n    prob_lluvia_proximas_horas: clima.hourly.precipitation_probability.slice(0, 24),\n    lluvia_proximos_dias: clima.daily.precipitation_sum,\n    prob_lluvia_max_dias: clima.daily.precipitation_probability_max\n};\n\nvar maxProbLluvia24h = Math.max(...datosClima.prob_lluvia_proximas_horas);\ndatosClima.max_prob_lluvia_24h = maxProbLluvia24h;\n\nflow.set('datosClima', datosClima);\n\nmsg.payload = datosClima;\n\nnode.status({fill:\"blue\", shape:\"dot\", text: \"Prob lluvia 24h: \" + maxProbLluvia24h + \"%\"});\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 280,
        "wires": [["debug_clima", "function_clima_influx"]]
    },
    {
        "id": "debug_clima",
        "type": "debug",
        "z": "flow_riego",
        "name": "üîç Ver datos clima",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 810,
        "y": 260,
        "wires": []
    },
    {
        "id": "function_clima_influx",
        "type": "function",
        "z": "flow_riego",
        "name": "üì¶ Clima a InfluxDB",
        "func": "var clima = msg.payload;\n\nmsg.payload = {\n    temp_actual: parseFloat(clima.temp_actual),\n    humedad_actual: parseFloat(clima.humedad_actual),\n    prob_lluvia_24h: parseFloat(clima.max_prob_lluvia_24h),\n    precipitacion: parseFloat(clima.precipitacion_actual)\n};\n\nmsg.measurement = \"clima_openmeteo\";\n\nnode.status({fill:\"blue\", shape:\"dot\", text:\"Prob lluvia: \" + clima.max_prob_lluvia_24h + \"%\"});\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 300,
        "wires": [["influxdb_out_clima"]]
    },
    {
        "id": "influxdb_out_clima",
        "type": "influxdb out",
        "z": "flow_riego",
        "influxdb": "influxdb_config",
        "name": "üíæ Clima a InfluxDB",
        "measurement": "",
        "precision": "",
        "retentionPolicy": "",
        "database": "riego_iot",
        "retentionPolicyV18Flux": "",
        "org": "e94345dd9c8f95c7",
        "bucket": "riego_iot",
        "x": 1050,
        "y": 300,
        "wires": []
    },
    {
        "id": "comment_ml",
        "type": "comment",
        "z": "flow_riego",
        "name": "ü§ñ MODELO ML - RANDOM FOREST (API Flask)",
        "info": "Llama a la API Flask que ejecuta el modelo Random Forest entrenado con datos hist√≥ricos de Jerusalen, Ecuador.\n\nAPI: http://localhost:5001/predict\nAccuracy: 99.9%",
        "x": 250,
        "y": 380,
        "wires": []
    },
    {
        "id": "inject_ml",
        "type": "inject",
        "z": "flow_riego",
        "name": "‚è∞ Cada 1 min",
        "props": [],
        "repeat": "60",
        "crontab": "",
        "once": false,
        "onceDelay": "10",
        "topic": "",
        "x": 150,
        "y": 440,
        "wires": [["function_preparar_api"]]
    },
    {
        "id": "function_preparar_api",
        "type": "function",
        "z": "flow_riego",
        "name": "üì¶ Preparar request API",
        "func": "// Obtener datos de sensores y clima del contexto\nvar sensores = flow.get('ultimosDatos') || {};\nvar clima = flow.get('datosClima') || {};\n\n// Validar que tenemos datos de sensores\nif (!sensores.humedad_suelo) {\n    node.status({fill:\"yellow\", shape:\"ring\", text:\"Esperando datos sensores\"});\n    return null;\n}\n\n// Obtener hora y mes actual\nvar ahora = new Date();\nvar hora = ahora.getHours();\nvar mes = ahora.getMonth() + 1; // getMonth() retorna 0-11\n\n// Preparar payload para la API Flask\nmsg.payload = {\n    humedad_suelo: sensores.humedad_suelo,\n    temperatura: sensores.temperatura,\n    humedad_ambiente: sensores.humedad_ambiente,\n    precipitacion: clima.precipitacion_actual || 0,\n    prob_lluvia: clima.max_prob_lluvia_24h || 0,\n    hora: hora,\n    mes: mes\n};\n\nmsg.headers = {\n    \"Content-Type\": \"application/json\"\n};\n\nnode.status({fill:\"blue\", shape:\"dot\", text:\"Enviando a API ML...\"});\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 440,
        "wires": [["http_request_ml"]]
    },
    {
        "id": "http_request_ml",
        "type": "http request",
        "z": "flow_riego",
        "name": "üß† API Flask ML",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://localhost:5001/predict",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 580,
        "y": 440,
        "wires": [["function_procesar_ml"]]
    },
    {
        "id": "function_procesar_ml",
        "type": "function",
        "z": "flow_riego",
        "name": "üîÑ Procesar respuesta ML",
        "func": "// Verificar si hubo error en la API\nif (msg.statusCode !== 200) {\n    node.status({fill:\"red\", shape:\"ring\", text:\"Error API: \" + msg.statusCode});\n    node.error(\"Error en API ML: \" + JSON.stringify(msg.payload));\n    return null;\n}\n\nvar respuesta = msg.payload;\n\n// Preparar resultado en formato compatible con el resto del flujo\nvar resultado = {\n    decision: respuesta.decision,\n    razon: \"ML: \" + respuesta.decision + \" (\" + respuesta.confianza + \"% confianza)\",\n    confianza: respuesta.confianza,\n    inputs: respuesta.inputs,\n    probabilidad_regar: respuesta.probabilidad_regar,\n    probabilidad_no_regar: respuesta.probabilidad_no_regar,\n    timestamp: respuesta.timestamp\n};\n\n// Actualizar status del nodo\nif (respuesta.decision === \"REGAR\") {\n    node.status({fill:\"blue\", shape:\"dot\", text:\"üíß REGAR (\" + respuesta.confianza + \"%)\"});\n} else {\n    node.status({fill:\"green\", shape:\"dot\", text:\"‚úã NO REGAR (\" + respuesta.confianza + \"%)\"});\n}\n\nmsg.payload = resultado;\nmsg.decision = respuesta.decision;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 440,
        "wires": [["switch_decision", "debug_ml", "function_decision_influx", "function_preparar_opcua"]]
    },
    {
        "id": "debug_ml",
        "type": "debug",
        "z": "flow_riego",
        "name": "üîç Ver decisi√≥n ML",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 630,
        "y": 400,
        "wires": []
    },
    {
        "id": "function_decision_influx",
        "type": "function",
        "z": "flow_riego",
        "name": "üì¶ Decisi√≥n a InfluxDB",
        "func": "var resultado = msg.payload;\n\nmsg.payload = {\n    decision: resultado.decision === \"REGAR\" ? 1 : 0,\n    confianza: resultado.confianza,\n    probabilidad_regar: resultado.probabilidad_regar || 0,\n    humedad_suelo: resultado.inputs.humedad_suelo,\n    temperatura: resultado.inputs.temperatura,\n    humedad_ambiente: resultado.inputs.humedad_ambiente || 0,\n    prob_lluvia: resultado.inputs.prob_lluvia || 0,\n    hora: resultado.inputs.hora,\n    mes: resultado.inputs.mes\n};\n\nmsg.measurement = \"decisiones_riego\";\n\nnode.status({fill:\"blue\", shape:\"dot\", text:\"Guardado en InfluxDB\"});\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 520,
        "wires": [["influxdb_out_decision"]]
    },
    {
        "id": "influxdb_out_decision",
        "type": "influxdb out",
        "z": "flow_riego",
        "influxdb": "influxdb_config",
        "name": "üíæ Decisi√≥n a InfluxDB",
        "measurement": "",
        "precision": "",
        "retentionPolicy": "",
        "database": "riego_iot",
        "retentionPolicyV18Flux": "",
        "org": "e94345dd9c8f95c7",
        "bucket": "riego_iot",
        "x": 900,
        "y": 480,
        "wires": []
    },
    {
        "id": "switch_decision",
        "type": "switch",
        "z": "flow_riego",
        "name": "üîÄ ¬øRegar?",
        "property": "decision",
        "propertyType": "msg",
        "rules": [
            { "t": "eq", "v": "REGAR", "vt": "str" },
            { "t": "eq", "v": "NO_REGAR", "vt": "str" }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 610,
        "y": 440,
        "wires": [["function_preparar_mqtt"], ["function_preparar_mqtt"]]
    },
    {
        "id": "function_preparar_mqtt",
        "type": "function",
        "z": "flow_riego",
        "name": "Preparar comando",
        "func": "msg.payload = msg.decision;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 440,
        "wires": [["mqtt_out_prediccion"]]
    },
    {
        "id": "mqtt_out_prediccion",
        "type": "mqtt out",
        "z": "flow_riego",
        "name": "üì§ Enviar a ESP32",
        "topic": "pastizal/prediccion",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker_hivemq",
        "x": 990,
        "y": 440,
        "wires": []
    },
    {
        "id": "comment_control",
        "type": "comment",
        "z": "flow_riego",
        "name": "üéÆ CONTROL MANUAL",
        "info": "",
        "x": 160,
        "y": 560,
        "wires": []
    },
    {
        "id": "inject_on",
        "type": "inject",
        "z": "flow_riego",
        "name": "üíß ABRIR V√°lvula",
        "props": [{ "p": "payload" }],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "ON",
        "payloadType": "str",
        "x": 170,
        "y": 620,
        "wires": [["mqtt_out_control"]]
    },
    {
        "id": "inject_off",
        "type": "inject",
        "z": "flow_riego",
        "name": "üî¥ CERRAR V√°lvula",
        "props": [{ "p": "payload" }],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "OFF",
        "payloadType": "str",
        "x": 180,
        "y": 680,
        "wires": [["mqtt_out_control"]]
    },
    {
        "id": "mqtt_out_control",
        "type": "mqtt out",
        "z": "flow_riego",
        "name": "üì§ Control v√°lvula",
        "topic": "pastizal/valvula/control",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker_hivemq",
        "x": 430,
        "y": 650,
        "wires": []
    },
    {
        "id": "comment_opcua",
        "type": "comment",
        "z": "flow_riego",
        "name": "üè≠ CONTROL FACTORY I/O (OPC-UA ‚Üí CODESYS)",
        "info": "Env√≠a la decisi√≥n del modelo ML a CODESYS via OPC-UA para controlar la v√°lvula en Factory I/O",
        "x": 250,
        "y": 760,
        "wires": []
    },
    {
        "id": "opcua_endpoint",
        "type": "OpcUa-Endpoint",
        "endpoint": "opc.tcp://localhost:4840",
        "secpol": "None",
        "secmode": "None",
        "login": false,
        "credentials": {}
    },
    {
        "id": "function_preparar_opcua",
        "type": "function",
        "z": "flow_riego",
        "name": "üè≠ Preparar OPC-UA",
        "func": "var decision = msg.decision;\n\nmsg.topic = \"ns=4;s=|var|CODESYS Control Win V3 x64.Application.GVL_Riego.bOrdenRegar;datatype=Boolean\";\nmsg.payload = (decision === \"REGAR\");\n\nnode.status({fill: decision === \"REGAR\" ? \"blue\" : \"green\", shape:\"dot\", text: decision});\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 190,
        "y": 820,
        "wires": [["opcua_client_write"]]
    },
    {
        "id": "opcua_client_write",
        "type": "OpcUa-Client",
        "z": "flow_riego",
        "endpoint": "opcua_endpoint",
        "action": "write",
        "deadbandtype": "a",
        "deadbandvalue": 1,
        "time": 10,
        "timeUnit": "s",
        "certificate": "n",
        "localfile": "",
        "localkeyfile": "",
        "securitymode": "None",
        "securitypolicy": "None",
        "folderName4PKI": "",
        "name": "üè≠ OPC-UA CODESYS",
        "x": 430,
        "y": 820,
        "wires": [["debug_opcua"]]
    },
    {
        "id": "debug_opcua",
        "type": "debug",
        "z": "flow_riego",
        "name": "üîç Ver respuesta OPC-UA",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 670,
        "y": 820,
        "wires": []
    }
]